
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/brainboxweb/advent/24_Packing/main.go (99.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package main

import (
        "bufio"
        "bytes"
        "math/rand"
        "sort"
        "strconv"
        "strings"
        "time"
)

type Parcel int

func (p Parcel) toString() string <span class="cov8" title="1">{
        return strconv.Itoa(int(p))
}</span>

type Group struct {
        parcels   []Parcel
        maxWeight int
}

func (g Group) weight() (weight int) <span class="cov8" title="1">{
        for _, parcel := range g.parcels </span><span class="cov8" title="1">{
                weight += int(parcel)
        }</span>
        <span class="cov8" title="1">return weight</span>
}

func (g Group) len() int <span class="cov8" title="1">{
        return len(g.parcels)
}</span>

func (g *Group) Add(p Parcel) bool <span class="cov8" title="1">{
        //Add... unless it exceeds maxweight
        if g.weight()+int(p) &gt; g.maxWeight </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">g.parcels = append(g.parcels, p)
        return true</span>
}

type Sleigh struct {
        groups []Group
}

func (s *Sleigh) addParcels(parcels []Parcel) bool <span class="cov8" title="1">{
        //Need descending order???
        //tototal weufght:
        totalWeight := 0
        for _, parcel := range parcels </span><span class="cov8" title="1">{
                totalWeight += int(parcel)
        }</span>
        <span class="cov8" title="1">groupWeight := totalWeight / len(s.groups)
        //Inform the Groups
        for k, _ := range s.groups </span><span class="cov8" title="1">{
                s.groups[k].maxWeight = groupWeight
        }</span>

        <span class="cov8" title="1">for _, parcel := range parcels </span><span class="cov8" title="1">{
                for k, _ := range s.groups </span><span class="cov8" title="1">{
                        ok := s.groups[k].Add(parcel)
                        if ok </span><span class="cov8" title="1">{
                                break</span> //parcel placed successfully
                        }
                }
        }

        //Check that ALL parcels have been placed.
        <span class="cov8" title="1">parcelCount := 0
        for _, group := range s.groups </span><span class="cov8" title="1">{
                parcelCount += len(group.parcels)
        }</span>
        <span class="cov8" title="1">if parcelCount != len(parcels) </span><span class="cov8" title="1">{
                return false
        }</span>

        //Check for balance
        <span class="cov8" title="1">for _, group := range s.groups </span><span class="cov8" title="1">{
                if groupWeight != group.weight() </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (s *Sleigh) sort() <span class="cov8" title="1">{
        sort.Sort(s)

        //also need to sort each group
        for k, group := range s.groups </span><span class="cov8" title="1">{

                ints := []int{}
                for _, parcel := range group.parcels </span><span class="cov8" title="1">{
                        ints = append(ints, int(parcel))
                }</span>
                //sort them
                <span class="cov8" title="1">sort.Ints(ints)

                //write them back
                newParcels := []Parcel{}
                for _, val := range ints </span><span class="cov8" title="1">{

                        newParcel := Parcel(val)
                        newParcels = append(newParcels, newParcel)
                }</span>
                <span class="cov8" title="1">s.groups[k].parcels = newParcels</span>
        }
}

func (s *Sleigh) GetInfo() (label string, sizeFirstGroup int, quantumEntanglement int) <span class="cov8" title="1">{

        s.sort()

        sizeFirstGroup = len(s.groups[0].parcels)

        quantumEntanglement = 1
        for _, val := range s.groups[0].parcels </span><span class="cov8" title="1">{
                quantumEntanglement *= int(val)
        }</span>

        <span class="cov8" title="1">chunks := []string{}
        for _, group := range s.groups </span><span class="cov8" title="1">{

                strParcels := []string{}
                for _, parcel := range group.parcels </span><span class="cov8" title="1">{

                        strParcels = append(strParcels, parcel.toString())
                }</span>

                <span class="cov8" title="1">chunk := strings.Join(strParcels, ",")
                chunks = append(chunks, chunk)</span>

        }

        <span class="cov8" title="1">label = strings.Join(chunks, "|")

        return label, sizeFirstGroup, quantumEntanglement</span>
}

//Need to be ab
func (s Sleigh) Len() int <span class="cov8" title="1">{
        return len(s.groups)
}</span>
func (s Sleigh) Swap(i, j int) <span class="cov8" title="1">{
        s.groups[i], s.groups[j] = s.groups[j], s.groups[i]
}</span>
func (s Sleigh) Less(i, j int) bool <span class="cov8" title="1">{

        if s.groups[i].len() &lt; s.groups[j].len() </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if s.groups[i].len() &gt; s.groups[j].len() </span><span class="cov8" title="1">{
                return false
        }</span>

        //Need some quantum entanglement
        <span class="cov8" title="1">quanti := 1
        for _, parcel := range s.groups[i].parcels </span><span class="cov8" title="1">{
                quanti *= int(parcel)
        }</span>
        <span class="cov8" title="1">quantj := 1
        for _, parcel := range s.groups[j].parcels </span><span class="cov8" title="1">{
                quantj *= int(parcel)
        }</span>
        <span class="cov8" title="1">return quanti &lt; quantj</span>
}

func parse(input string) []int <span class="cov8" title="1">{
        b := bytes.NewBufferString(input)
        scanner := bufio.NewScanner(b)

        items := []int{}

        for scanner.Scan() </span><span class="cov8" title="1">{
                text := scanner.Text()

                int, _ := strconv.Atoi(text)
                items = append(items, int)
        }</span>

        <span class="cov8" title="1">return items</span>
}

type Result struct {
        sizeOfFirstPile     int
        quantumEntanglement int
}

func Run(input string, groupCount int) (quantumEntanglement int) <span class="cov8" title="1">{

        intParcels := parse(input)

        //sort into descending order
        //sort.Sort(sort.Reverse(sort.intParcels))



</span>
        results := make(map[string]Result)

        groups := []Group{}
        for i := 0; i &lt; groupCount; i++ {</span><span class="cov8" title="1">
                groups = append(groups, Group{})
        }
</span>
        s<span class="cov8" title="1">leigh := Sleigh{groups}

        //try removing a different package on each loop
        for i := 0 ; i &lt; len(items); i++ </span><span class="cov8" title="1">{

                //switch the parcels around
                i</span>ntParcelsCopy := make([]int, len(intParcels))
                copy(intParcelsCopy, intParcels)
                <span class="cov8" title="1">intParcelsCopy = append(intParcelsCopy[:i], intParcelsCopy[i+1:]...)
                
</span>                parcels :</span>= []Parcel{}
                for _, item := range intParcelsCopy {
                        parcel := Parcel(item)
                <span class="cov8" title="1">        parcels = append(parcels, parcel)
                }

                ok := sleigh.addParcels</span>(parcels)
                if !ok {
                        continue
                }

        <span class="cov8" title="1">        label, sizeOne, qe := sleigh.GetInfo()

</span>                result := Result{sizeOne, qe}
</span>                results[label] = result

</span>        }



</span>
</span>        ok := sleigh.addParcels(parcels)

</span>

/<span class="cov8" title="1">/        //Okay... this is silly
//        rand.Seed(time.Now().UnixNano())
</span>//        for i := 0; i &lt; 100000; i++ {
</span>//
//        </span>        shuffle(intParcels)
//
//                groups := []Group{}
/<span class="cov8" title="1">/                for i := </span>0; i &lt; groupCount; i++ {
//                        groups = append(groups, Group{})
//                }
//
//                sleigh := Slei</span><span class="cov8" title="1">gh{groups}
//
//                parcels := []Parcel{}
//</span>                for _, item := range intParcels {
//                        parcel := Parcel(item)
//                        parcels = append(parcels, parcel)
//                }
//
//                ok := sleigh.addParcels(parcels)
//                if !ok {
//                        continue
//                }
//
//                label, sizeOne, qe := sleigh.GetInfo()
//
//                result := Result{sizeOne, qe}
//                results[label] = result
//        }

        //The winner is the SMALLEST... or - the case of a tie - the one with the smallest qe

        sizeGroupOneMinimum := 10000000000000
        for _, result := range results {
                if result.sizeOfFirstPile &lt; sizeGroupOneMinimum {
                        sizeGroupOneMinimum = result.sizeOfFirstPile
                }
        }

        winningResults := []Result{}
        for _, result := range results {
                if result.sizeOfFirstPile == sizeGroupOneMinimum {
                        winningResults = append(winningResults, result)
                }
        }

        QEmin := 10000000000000000
        for _, result := range winningResults {
                if result.quantumEntanglement &lt; QEmin {
                        QEmin = result.quantumEntanglement
                }
        }

        return QEmin
}
//
//func shuffle(a []int) {
//        for i := range a {
//                j := rand.Intn(i + 1)
//                a[i], a[j] = a[j], a[i]
//        }
//}


//
//func (a []int) Len() int      { return len(d) }
//func (d distances) Swap(i, j int) { d[i], d[j] = d[j], d[i] }
//func (d distances) Less(i, j int) bool {
//        if d[i].Distance &gt; d[j].Distance { //reverse search
//                return true
//        } else {
//                return false
//        }
//}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
